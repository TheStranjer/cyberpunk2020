import { weaponTypes, meleeAttackTypes, rangedAttackTypes, attackSkills, concealability, availability, reliability, getStatNames } from "../lookups.js";
import { formulaHasDice } from "../dice.js";
import { localize, cwHasType } from "../utils.js";
import { getMartialKeyByName } from '../translations.js'

/**
 * Extend the basic ItemSheet with some very simple modifications
 * @extends {ItemSheet}
 */
export class CyberpunkItemSheet extends ItemSheet {

  /** @override */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["cyberpunk", "sheet", "item"],
      width: 520,
      height: 480,
      tabs: [{ navSelector: ".sheet-tabs", contentSelector: ".sheet-body", initial: "description" }]
    });
  }

  /** @override */
  get template() {
    const path = "systems/cyberpunk2020/templates/item";
    // Return a single sheet for all item types.
    // return `${path}/item-sheet.hbs`;

    // Alternatively, you could use the following return statement to do a
    // unique item sheet by type, like `weapon-sheet.hbs`.
    return `${path}/item-sheet.hbs`;
  }

  /* -------------------------------------------- */

  /** @override */
  getData() {
    // This means the handlebars data and the form edit data actually mirror each other
    const data = super.getData();
    data.system = this.item.system;

    switch (this.item.type) {
      case "weapon":
        this._prepareWeapon(data);
        break;
    
      case "armor":
        this._prepareArmor(data);
        break;

      case "skill":
        this._prepareSkill(data);
        break;

      case "cyberware": 
        this._prepareCyberware(data); 
        break;

      default:
        break;
    }
    return data;
  }

  _prepareSkill(sheet) {
    sheet.stats = getStatNames();
  }

  _prepareWeapon(sheet) {
    sheet.weaponTypes = Object.values(weaponTypes).sort();
    const isMelee = this.item.system.weaponType === weaponTypes.melee;
    sheet.attackTypes = isMelee ? Object.values(meleeAttackTypes).sort() : Object.values(rangedAttackTypes).sort();
    sheet.concealabilities = Object.values(concealability);
    sheet.availabilities = Object.values(availability);
    sheet.reliabilities = Object.values(reliability);

    const actor = this.item?.parent;
    const wType = this.item.system.weaponType || weaponTypes.pistol;
    const baseKeys = attackSkills[wType] || [];
    const includeMartials = (wType === weaponTypes.melee) && (this.item.system.attackType === meleeAttackTypes.martial);
    const martialKeys = includeMartials ? (actor?.trainedMartials?.() || []).map(getMartialKeyByName) : [];
    sheet.attackSkills = [...baseKeys, ...martialKeys].map(k => localize("Skill"+k));

    // TODO: Be not so inefficient for this
    if(!sheet.attackSkills.length && this.actor) {
      if(this.actor) {
        sheet.attackSkills = this.actor.itemTypes.skill.map(skill => skill.name).sort();
      }
    }
  }

  _prepareArmor(sheet) {
    
  }

/**
 * Prepares data for the cyberware item sheet template.
 * Gathers option lists, selected values, and labels.
*/
_prepareCyberware(sheet) {
  const L = (k) => {
    if (game.i18n.has(`CYBERPUNK.${k}`)) return game.i18n.localize(`CYBERPUNK.${k}`);
    if (game.i18n.has(k)) return game.i18n.localize(k);
    return k;
  };

  const sys = this.item?.system ?? {};
  const cwt = sys.CyberWorkType ?? {};
  sheet.cw = sheet.cw ?? {};

  sheet.cw.types = Array.isArray(cwt.Types) && cwt.Types.length
    ? [...cwt.Types]
    : (cwt.Type ? [cwt.Type] : ["Descriptive"]);

  const mapKeyToLoc = (k) => {
    switch (k) {
      case "Descriptive": return game.i18n.localize("CYBERPUNK.CWT_Type_Descriptive");
      case "Characteristic": return game.i18n.localize("CYBERPUNK.CWT_Type_Characteristic");
      case "Armor": return game.i18n.localize("CYBERPUNK.CWT_Type_Armor");
      case "Weapon": return game.i18n.localize("CYBERPUNK.CWT_Type_Weapon");
      case "Implant": return game.i18n.localize("CYBERPUNK.CWT_Type_Implant");
      case "Chip": return game.i18n.localize("CYBERPUNK.CWT_Type_Chip");
      default: return k;
    }
  };
  sheet.cw.typeLabels = sheet.cw.types.map(mapKeyToLoc);

  // Ensure Module exists for bindings
  if (!this.item.system.Module) {
    this.item.updateSource({
      "system.Module": {
        IsModule: false,
        AllowedParentCyberwareType: [],
        TakesOptions: 0
      }
    });
  }

  // Characteristic: stats and checks
  const STAT_KEYS = [
    { key: "int", label: L("IntFull") },
    { key: "ref", label: L("RefFull") },
    { key: "tech", label: L("TechFull") },
    { key: "cool", label: L("CoolFull") },
    { key: "attr", label: L("AttrFull") },
    { key: "luck", label: L("LuckFull") },
    { key: "ma", label: L("MaFull") },
    { key: "bt", label: L("BtFull") },
    { key: "emp", label: L("EmpFull") }
  ];

  const CHECK_KEYS = [
    { key: "Initiative", label: L("CWT_Checks_Initiative") },
    { key: "SaveStun", label: L("CWT_Checks_SaveStun") }
  ];

  const findLabel = (list, key) => list.find((i) => i.key === key)?.label ?? key;

  const statObj = cwt.Stat ?? {};
  sheet.cw.currentStats = Object.keys(statObj).map((k) => ({ key: k, label: findLabel(STAT_KEYS, k) }));
  sheet.cw.statRemain = STAT_KEYS.filter((s) => !(s.key in statObj));

  const checkObj = cwt.Checks ?? {};
  sheet.cw.currentChecks = Object.keys(checkObj).map((k) => ({ key: k, label: findLabel(CHECK_KEYS, k) }));
  sheet.cw.checkRemain = CHECK_KEYS.filter((c) => !(c.key in checkObj));

  // Armor: locations and penalties
  const LOCATION_KEYS = [
    { key: "Head", label: L("Head") },
    { key: "Torso", label: L("Torso") },
    { key: "lArm", label: L("lArm") },
    { key: "rArm", label: L("rArm") },
    { key: "lLeg", label: L("lLeg") },
    { key: "rLeg", label: L("rLeg") }
  ];

  const PENALTY_KEYS = STAT_KEYS;

  const locObj = cwt.Locations ?? {};
  sheet.cw.currentLocations = Object.keys(locObj).map((k) => ({ key: k, label: findLabel(LOCATION_KEYS, k) }));
  sheet.cw.locationRemain = LOCATION_KEYS.filter((l) => !(l.key in locObj));

  const penObj = cwt.Penalties ?? {};
  sheet.cw.currentPenalties = Object.keys(penObj).map((k) => ({ key: k, label: findLabel(PENALTY_KEYS, k) }));
  sheet.cw.penaltyRemain = PENALTY_KEYS.filter((p) => !(p.key in penObj));

  // Skills (from the actor, if present)
  const actorSkills = this.actor?.itemTypes?.skill ?? [];
  sheet.cw.skillOptions = actorSkills.map((s) => s.name).sort((a, b) => a.localeCompare(b));
  sheet.cw.currentSkills = Object.keys(cwt.Skill ?? {}).sort();
  sheet.cw.currentChipSkills = Object.keys(cwt.ChipSkills ?? {}).sort();
  sheet.cw.hasActor = !!this.actor;

  // Weapon options: from the actor's inventory or from Items
  if (this.actor) {
    sheet.cw.weaponOptions = (this.actor.itemTypes.weapon ?? [])
      .map((w) => ({ id: w.id, name: w.name }))
      .sort((a, b) => a.name.localeCompare(b.name));
  } else {
    const allItems = Array.from(game.items ?? []);
    sheet.cw.weaponOptions = allItems
      .filter((i) => i.type === "weapon")
      .map((w) => ({ id: w.id, name: w.name }))
      .sort((a, b) => a.name.localeCompare(b.name));
  }

  // Implant: allowed installation slot
  const bodyAll = [
    { key: "Head", label: L("Head") },
    { key: "Torso", label: L("Torso") },
    { key: "Arm", label: L("Arm") },
    { key: "Leg", label: L("Leg") },
    { key: "Nervous", label: L("Nervous") },
    { key: "Chip", label: L("Chip") }
  ];
  sheet.cw.bodyZones = bodyAll;

  sheet.weaponTypes = Object.values(weaponTypes).sort();
  const cwW = this.item.system?.CyberWorkType?.Weapon || {};
  const isMelee = cwW.weaponType === weaponTypes.melee;
  sheet.attackTypes = isMelee ? Object.values(meleeAttackTypes).sort() : Object.values(rangedAttackTypes).sort();
  sheet.concealabilities = Object.values(concealability);
  sheet.availabilities = Object.values(availability);
  sheet.reliabilities = Object.values(reliability);

  const actor = this.item?.parent;
  const baseKeys = attackSkills[cwW.weaponType || weaponTypes.pistol] || [];
  const includeMartials = isMelee && (cwW.attackType === meleeAttackTypes.martial);
  const martialKeys = includeMartials ? (actor?.trainedMartials?.() || []).map(getMartialKeyByName) : [];
  sheet.attackSkills = [...baseKeys, ...martialKeys].map(k => localize("Skill"+k));
  
  if (!sheet.attackSkills.length && this.actor) {
    sheet.attackSkills = (this.actor.itemTypes.skill || []).map(s => s.name).sort((a, b) => a.localeCompare(b));
  }

  const TYPE_CHOICES_BASE = [
    { value: "CyberArm", localKey: "CWT_ImplantType_CyberArm" },
    { value: "CyberLeg", localKey: "CWT_ImplantType_CyberLeg" },
    { value: "CyberAudio", localKey: "CWT_ImplantType_CyberAudio" },
    { value: "CyberOptic", localKey: "CWT_ImplantType_CyberOptic" },
    { value: "CyberTorso", localKey: "CWT_ImplantType_CyberTorso" }
  ];

  const typeAliases = {
    "CYBERARM": "CyberArm",
    "CYBERHAND": "CyberArm",
    "CYBERLEG": "CyberLeg",
    "CYBERFOOT": "CyberLeg",
    "CYBEREAR": "CyberAudio",
    "CYBEROPTIC":"CyberOptic",
    "IMPLANT": "CyberTorso",
    "Arm": "CyberArm", "Leg": "CyberLeg",
    "Ear": "CyberAudio", "Eye": "CyberOptic", "Torso": "CyberTorso"
  };

  const pickType = (t) => {
    if (!t) return null;
    if (typeof t === "string") {
      const k = t.trim();
      return typeAliases[k] || k;
    }
    if (typeof t === "object") {
      const k = (t.key ?? t.value ?? t.name);
      if (typeof k === "string") {
        const s = k.trim();
        return typeAliases[s] || s;
      }
    }
    return null;
  };

  const worldTypes = Array.from(game.items ?? [])
    .filter(i => i.type === "cyberware")
    .map(i => pickType(i.system?.cyberwareType))
    .filter(Boolean);

  const actorTypes = this.actor
    ? (this.actor.itemTypes.cyberware ?? [])
        .map(i => pickType(i.system?.cyberwareType))
        .filter(Boolean)
    : [];

  const known = new Set(TYPE_CHOICES_BASE.map(c => c.value));
  const extra = Array.from(new Set([...worldTypes, ...actorTypes]))
    .filter(v => typeof v === "string" && v.length && !known.has(v))
    .map(v => ({ value: v, localKey: v }));

  sheet.cw.parentCwTypeChoices = [...TYPE_CHOICES_BASE, ...extra];

    // Implant: free/taken options with automatic module accounting (only equipped modules count)
    const provided = Number(this.item.system?.CyberWorkType?.OptionsAvailable) || 0;
    let used = 0;
    if (this.actor) {
      const all = this.actor.items?.contents || [];
      const selfId = this.item.id;
      used = all
        .filter(i =>
          i.type === "cyberware" &&
          i.system?.Module?.IsModule &&
          i.system?.Module?.ParentId === selfId &&
          !!i.system?.equipped
        )
        .reduce((sum, m) => sum + (Number(m.system?.Module?.SlotsTaken) || 0), 0);
    }
    sheet.cw.implantSlotsUsed = used;
    sheet.cw.implantSlotsTotal = provided;
    sheet.cw.implantSlotsLeft = Math.max(0, provided - used);

    // Module: implants available on the actor that match the type (only equipped, same zone/side, exclude self)
    const isModule = !!this.item.system?.Module?.IsModule;
    if (isModule && this.actor) {
      const needType = this.item.system?.Module?.AllowedParentCyberwareType || "";
      const all = this.actor.items?.contents || [];

      const zoneOf = (it) => String(it.system?.MountZone || it.system?.CyberBodyType?.Type || "");
      const sideOf = (it) => String(it.system?.CyberBodyType?.Location || "");
      const needZone = zoneOf(this.item);
      const needSide = sideOf(this.item);

      // Count available slots of a candidate implant (only equipped modules count)
      const leftFor = (p) => {
        const provided = Number(p.system?.CyberWorkType?.OptionsAvailable || 0);
        const used = all
          .filter(i =>
            i.type === "cyberware" &&
            i.system?.Module?.IsModule &&
            i.system?.Module?.ParentId === p.id &&
            !!i.system?.equipped
          )
          .reduce((sum, m) => sum + (Number(m.system?.Module?.SlotsTaken) || 0), 0);
        return Math.max(0, provided - used);
      };

      sheet.cw.parentImplants = all
        .filter(i =>
          i.type === "cyberware" &&
          cwHasType(i, "Implant") &&
          i.id !== this.item.id &&
          !!i.system?.equipped &&
          (!needType || String(i.system?.cyberwareType || "") === needType) &&
          (zoneOf(i) === needZone) &&
          (needZone === "Arm" || needZone === "Leg" ? (!needSide || sideOf(i) === needSide) : true)
        )
        .map(i => ({ id: i.id, name: i.name, left: leftFor(i) }));
    } else {
      sheet.cw.parentImplants = [];
    }

    // Implant: free/taken options (ONLY equipped modules count)
    if (cwHasType(this.item, "Implant")) {
      const provided = Number(this.item.system?.CyberWorkType?.OptionsAvailable) || 0;
      let used = 0;

      if (this.actor) {
        const all = this.actor.items?.contents || [];
        const selfId = this.item.id;
        used = all.reduce((sum, it) => {
          const mod = it.system?.Module;
          if (
            it.type === "cyberware" &&
            mod?.IsModule &&
            mod?.ParentId === selfId &&
            !!it.system?.equipped
          ) {
            return sum + (Number(mod.SlotsTaken) || 0);
          }
          return sum;
        }, 0);
      }

      sheet.cw.implantSlotsUsed = used;
      sheet.cw.implantSlotsTotal = provided;
      sheet.cw.implantSlotsLeft = Math.max(0, provided - used);
    }
}

  async _cwSet(path, value) {
    const update = {}; foundry.utils.setProperty(update, path, value);
    await this.item.update(update);
    this.render(false);
  }
  async _cwDelete(objPath, key) {
    const update = {};
    update[`${objPath}.-=${key}`] = null;
    await this.item.update(update);
    this.render(false);
  }

  async _cwAddKey(objPath, key, value) {
    const current = foundry.utils.duplicate(
      foundry.utils.getProperty(this.item.system, objPath) || {}
    );
    if (current[key] === value) return;

    current[key] = value;

    const update = {};
    foundry.utils.setProperty(update, `system.${objPath}`, current);
    await this.item.update(update);
    this.render(false);
  }

  _resolveSkillName(query) {
    const skills = this.actor?.itemTypes?.skill || [];
    const q = String(query || "").trim();
    if (!q || !skills.length) return null;
    const exact = skills.find(s => s.name === q);
    return exact ? exact.name : null;
  }

  /** @override */
  setPosition(options = {}) {
    const position = super.setPosition(options);
    const sheetBody = this.element.find(".sheet-body");
    const bodyHeight = position.height - 192;
    sheetBody.css("height", bodyHeight);
    return position;
  }

  /** @override */
  activateListeners(html) {
    super.activateListeners(html);

    // Everything below here is only needed if the sheet is editable
    if (!this.options.editable) return;

    // Roll handlers, click handlers, etc. would go here, same as actor sheet.
    html.find(".item-roll").click(this.item.roll.bind(this));
    html.find(".accel").click(() => this.item.accel());
    html.find(".decel").click(() => this.item.accel(true));

    ["select.cw-add-stat",
    "select.cw-add-check",
    "select.cw-add-location",
    "select.cw-add-penalty",
    "select.cw-add-mountpolicy"
    ].forEach(sel => {
      html.on("mousedown", sel, ev => { ev.currentTarget.value = ""; });
    });

    // Stat
    html.on("change", "select.cw-add-stat", async ev => {
      const key = ev.currentTarget.value;
      if (!key) return;
      await this._cwSet(`system.CyberWorkType.Stat.${key}`, 0);
      ev.currentTarget.value = "";
    });

    // Checks
    html.on("change", "select.cw-add-check", async ev => {
      const key = ev.currentTarget.value;
      if (!key) return;

      const checks = foundry.utils.duplicate(this.item.system?.CyberWorkType?.Checks || {});
      if (checks[key] == null) checks[key] = 0;

      await this.item.update({ "system.CyberWorkType.Checks": checks });
    });

    // Locations
    html.on("change", "select.cw-add-location", async ev => {
      const key = ev.currentTarget.value;
      if (!key) return;
      await this._cwSet(`system.CyberWorkType.Locations.${key}`, 0);
      ev.currentTarget.value = "";
    });

    // Penalties
    html.on("change", "select.cw-add-penalty", async ev => {
      const key = ev.currentTarget.value;
      if (!key) return;
      await this._cwSet(`system.CyberWorkType.Penalties.${key}`, 0);
      ev.currentTarget.value = "";
    });

    // MountPolicy
    html.on("change", "select.cw-add-mountpolicy", async ev => {
      const key = ev.currentTarget.value;
      if (!key) return;
      const mp = this.item.system?.CyberWorkType?.MountPolicy;
      const list = Array.isArray(mp) ? [...mp] : (mp ? [mp] : []);
      if (!list.includes(key)) list.push(key);
      await this._cwSet("system.CyberWorkType.MountPolicy", list);
      ev.currentTarget.value = "";
    });

    // Skill search
    const addSkillFromInput = async (inputEl, pathPrefix) => {
      const name = this._resolveSkillName(inputEl?.value || "");
      if (!name) return;
      await this._cwSet(`${pathPrefix}.${name}`, 0);
      inputEl.value = "";
      inputEl.blur();
    };

    // Characteristic.Skill
    html.on("input", "input[name='cw-skill-search']", ev => {
      addSkillFromInput(ev.currentTarget, "system.CyberWorkType.Skill");
    });

    // Chip.ChipSkills
    html.on("input", "input[name='cw-chip-skill-search']", async ev => {
      await addSkillFromInput(ev.currentTarget, "system.CyberWorkType.ChipSkills");
      await this._cp_syncChipLevelsToSkills();
      if (typeof this._cp_syncActiveFlagsToSkills === "function") {
        await this._cp_syncActiveFlagsToSkills();
      }
    });

    html.on("mousedown", "input[name='cw-skill-search'], input[name='cw-chip-skill-search']", ev => {
      const el = ev.currentTarget;
      if (document.activeElement === el) {
        ev.preventDefault();
        const listId = el.getAttribute("list");
        el.removeAttribute("list");
        el.blur();
        setTimeout(() => {
          el.setAttribute("list", listId);
        }, 150);
      }
    });

    // Chip sheet
    html.on("change", "input[name^='system.CyberWorkType.ChipSkills.']", async (ev) => {
      const actor = this.item.actor;
      if (!actor) return;

      const name = ev.currentTarget.name.split(".").pop();
      const n = Number(ev.currentTarget.value);
      const value = Number.isFinite(n) ? n : 0;

      const skills = actor.items.filter(i => i.type === "skill" && i.name === name);
      if (skills.length) {
        const updates = skills.map(s => ({ _id: s.id, "system.chipLevel": value }));
        await actor.updateEmbeddedDocuments("Item", updates, { render: false });
      }
    });

    // Remove
    html.on("click", ".cw-remove-stat", ev => this._cwDelete("system.CyberWorkType.Stat", ev.currentTarget.dataset.key));
    html.on("click", ".cw-remove-check", ev => this._cwDelete("system.CyberWorkType.Checks", ev.currentTarget.dataset.key));
    html.on("click", ".cw-remove-skill", ev => this._cwDelete("system.CyberWorkType.Skill", ev.currentTarget.dataset.key));
    html.on("click", ".cw-remove-location", ev => this._cwDelete("system.CyberWorkType.Locations", ev.currentTarget.dataset.key));
    html.on("click", ".cw-remove-penalty", ev => this._cwDelete("system.CyberWorkType.Penalties", ev.currentTarget.dataset.key));
    html.on("click", ".cw-remove-chipskill", async ev => {
      await this._cwDelete("system.CyberWorkType.ChipSkills", ev.currentTarget.dataset.key);
      await this._cp_syncChipLevelsToSkills();
      if (typeof this._cp_syncActiveFlagsToSkills === "function") {
        await this._cp_syncActiveFlagsToSkills();
      }
    });
    html.on("click", ".cw-remove-mount", async ev => {
      const key = ev.currentTarget.dataset.key;
      const mp = this.item.system?.CyberWorkType?.MountPolicy || [];
      const list = mp.filter(x => x !== key);
      await this._cwSet("system.CyberWorkType.MountPolicy", list);
    });

    // Change body zone: if not Arm/Leg — clear the side
    html.on("change", "select[name='system.CyberBodyType.Type']", async ev => {
      const t = ev.currentTarget.value;
      if (t !== "Arm" && t !== "Leg") {
        await this._cwSet("system.CyberBodyType.Location", "");
      }
    });

    // Weapon selection: always store the id in system.CyberWorkType.ItemId
    html.on("change", "select.cw-select-weapon", async ev => {
      const selectedId = ev.currentTarget.value || "";
      await this._cwSet("system.CyberWorkType.ItemId", selectedId);
    });

    // Rerender when module toggle changes
    html.find('input[name="system.Module.IsModule"]').on('change', (ev) => {
      this._onSubmit(ev);
    });

    // HumanityCost Roll
    html.find('.humanity-cost-roll').click(async ev => {
      ev.stopPropagation();
      const cyber = this.object;
      const hc = cyber.system.humanityCost;
      let loss = 0;
      // determine if humanity cost is a number or dice
      if (formulaHasDice(hc)) {
        // roll the humanity cost
        let r = await new Roll(hc).evaluate();
        loss = r.total ? r.total : 0;
      } else {
        const num = Number(hc);
        loss = (isNaN(num)) ? 0 : num;
      }
      cyber.system.humanityLoss = loss;
      cyber.sheet.render(true);
    });

    // Recalculate available slots when changing “Slots provided”
    html.find('input[name="system.CyberWorkType.OptionsAvailable"]').on('change', (ev) => {
      this._onSubmit(ev);
    });

    html.on("change", "select[name='system.Module.ParentId']", async ev => {
      await this._cwSet("system.Module.ParentId", String(ev.currentTarget.value || ""));
    });

    // MODULE: implant replacement
    html.on("change", "select[name='system.Module.ParentId']", async ev => {
      const prevId = this.item.system?.Module?.ParentId || "";
      const newId = String(ev.currentTarget.value || "");

      await this._cwSet("system.Module.ParentId", newId);

      const refresh = (id) => {
        const it = this.actor?.items?.get(id);
        if (it?.sheet?.rendered) it.sheet.render(true);
      };
      if (prevId && prevId !== newId) refresh(prevId);
      if (newId) refresh(newId);
    });

    // MODULE: change “occupies options”
    html.on("change", "input[name='system.Module.SlotsTaken']", async ev => {
      const n = Number(ev.currentTarget.value);
      await this._cwSet("system.Module.SlotsTaken", Number.isFinite(n) ? n : 0);

      const parentId = this.item.system?.Module?.ParentId || "";
      const parent = parentId ? this.actor?.items?.get(parentId) : null;
      if (parent?.sheet?.rendered) parent.sheet.render(true);
    });

    // MODULE: turning off “Module” — freeing up options from the parent
    html.on("change", "input[name='system.Module.IsModule']", async ev => {
      const enabled = ev.currentTarget.checked;
      const prevId = this.item.system?.Module?.ParentId || "";
      await this._cwSet("system.Module.IsModule", enabled);
      if (!enabled && prevId) {
        await this._cwSet("system.Module.ParentId", "");
        const parent = this.actor?.items?.get(prevId);
        if (parent?.sheet?.rendered) parent.sheet.render(true);
      }
    });

    html.on("change", "select[name='system.cyberwareType']", async ev => {
      const v = ev.currentTarget.value;
      let bodyType = "";
      if (v === "CyberArm") bodyType = "Arm";
      else if (v === "CyberLeg") bodyType = "Leg";
      else if (v === "CyberTorso") bodyType = "Torso";
      else if (v === "CyberAudio" || v === "CyberOptic") bodyType = "Head";

      await this._cwSet("system.CyberBodyType.Type", bodyType);
      if (bodyType !== "Arm" && bodyType !== "Leg") {
        await this._cwSet("system.CyberBodyType.Location", "");
      }
    });

    // Changing the ChipSkills level
    html.on("change", "input[name^='system.CyberWorkType.ChipSkills.']", async ev => {
      const el = ev.currentTarget;
      const n = Number(el.value);
      await this._cwSet(el.name, Number.isFinite(n) ? n : 0);
      await this._cp_syncChipLevelsToSkills();
      if (typeof this._cp_syncActiveFlagsToSkills === "function") {
        await this._cp_syncActiveFlagsToSkills();
      }
    });

    html.on("change", "input[name='system.CyberWorkType.ChipActive']", async ev => {
      const checked = !!ev.currentTarget.checked;
      const prev = !!this.item.system?.CyberWorkType?.ChipActive;
      if (prev === checked) return;

      await this.item.update({ "system.CyberWorkType.ChipActive": checked }, { render: false });

      if (typeof this._cp_syncChipLevelsToSkills === "function") {
        await this._cp_syncChipLevelsToSkills();
      }

      if (typeof this._cp_syncActiveFlagsToSkills === "function") {
        await this._cp_syncActiveFlagsToSkills();
      }

      const actor = this.item.actor;
      if (actor?.sheet?.rendered) actor.sheet.render(true);
      const affectedNames = Object.keys(this.item.system?.CyberWorkType?.ChipSkills || {});
      for (const it of (actor?.items ?? [])) {
        if (it.type !== "skill") continue;
        if (!affectedNames.includes(it.name)) continue;
        if (it.sheet?.rendered) it.sheet.render(true);
      }
      this.render(true);
    });

    // SKILL SHEET: enabling/disabling the “chip” for a skill
    if (this.item.type === "skill") {
      html.on("change", "input[name='system.isChipped']", async (ev) => {
        const checked = !!ev.currentTarget.checked;
        const actor = this.item.actor;
        const skillName = this.item.name;

        const chips = actor ? actor.items.filter(i =>
          i.type === "cyberware" &&
          cwHasType(i, "Chip") &&
          i.system?.CyberWorkType?.ChipSkills &&
          Object.prototype.hasOwnProperty.call(i.system.CyberWorkType.ChipSkills, skillName)
        ) : [];

        if (actor && chips.length) {
          const chipUpdates = chips.map(ch => ({
            _id: ch.id,
            "system.CyberWorkType.ChipActive": checked
          }));
          await actor.updateEmbeddedDocuments("Item", chipUpdates, { render: false });
        }

        if (actor) {
          await actor.updateEmbeddedDocuments("Item", [
            { _id: this.item.id, "system.isChipped": checked }
          ], { render: false });
        } else {
          await this.item.update({ "system.isChipped": checked }, { render: false });
        }

        // If there are no chips, leave the manual chipLevel as it is
        if (actor && chips.length) {
          const agg = Math.max(0, ...chips.map(ch => Number(ch.system?.CyberWorkType?.ChipSkills?.[skillName] || 0)));
          if (Number(this.item.system?.chipLevel || 0) !== agg) {
            await actor.updateEmbeddedDocuments("Item", [
              { _id: this.item.id, "system.chipLevel": agg }
            ], { render: false });
          }
        }

        if (actor?.sheet?.rendered) actor.sheet.render(true);
        for (const ch of chips) if (ch.sheet?.rendered) ch.sheet.render(true);
        this.render(true);
      });
    }

    // SKILL SHEET: changing “Level (with chip)” synchronizes the corresponding level in the chips
    html.on("change", "input[name='system.chipLevel']", async (ev) => {
      const actor = this.item.actor;
      if (!actor) return;

      const skillName = this.item.name;
      const n = Number(ev.currentTarget.value);
      const value = Number.isFinite(n) ? n : 0;

      const chips = actor.items.filter(i =>
        i.type === "cyberware" &&
        cwHasType(i, "Chip") &&
        i.system?.CyberWorkType?.ChipSkills &&
        Object.prototype.hasOwnProperty.call(i.system.CyberWorkType.ChipSkills, skillName)
      );

      if (!chips.length) return;

      const updates = chips.map(ch => ({
        _id: ch.id,
        [`system.CyberWorkType.ChipSkills.${skillName}`]: value
      }));
      await actor.updateEmbeddedDocuments("Item", updates, { render: false });

      if (typeof this._cp_syncChipLevelsToSkills === "function") {
        await this._cp_syncChipLevelsToSkills();
      }

      if (actor?.sheet?.rendered) actor.sheet.render(true);
      for (const ch of chips) if (ch.sheet?.rendered) ch.sheet.render(true);
      this.render(true);
    });

    // Open/close menu
    html.on("click", ".cw-ms-trigger", ev => {
      ev.preventDefault();
      const root = ev.currentTarget.closest(".cw-ms");
      if (!root) return;
      root.classList.toggle("open");
    });

    // Close on click outside the block
    html.on("click", ev => {
      if ($(ev.target).closest(".cw-ms").length) return;
      html.find(".cw-ms.open").removeClass("open");
    });

    // Selecting checkboxes within the menu
    html.on("change", ".cw-ms-menu input[type=checkbox]", async ev => {
      const root = ev.currentTarget.closest(".cw-ms");
      if (!root) return;

      const menu = root.querySelector(".cw-ms-menu");
      let next = Array.from(menu.querySelectorAll("input[type=checkbox]:checked")).map(i => i.value);

      const changed = ev.currentTarget.value;
      const turnedOn = ev.currentTarget.checked;

      if (changed === "Descriptive" && turnedOn) {
        next = ["Descriptive"];
        menu.querySelectorAll("input[type=checkbox]").forEach(i => {
          i.checked = (i.value === "Descriptive");
        });
      } else if (turnedOn) {
        const desc = menu.querySelector('input[value="Descriptive"]');
        if (desc) desc.checked = false;
        next = next.filter(v => v !== "Descriptive");
      }

      if (!next.length) {
        next = ["Descriptive"];
        const desc = menu.querySelector('input[value="Descriptive"]');
        if (desc) desc.checked = true;
      }

      await this._cwSet("system.CyberWorkType.Types", next);
    });

    // Auto-refresh on related Item updates (keeps module/implant sheets in sync)
    if (this.actor) {
      const actorId = this.actor.id;

      this._cp_boundOnItemUpdate = (item, changes) => {
        if (item?.parent?.id !== actorId) return;
        if (item.type !== "cyberware") return;

        const sys = changes?.system || {};
        const touched =
          ("equipped" in sys) ||
          ("MountZone" in sys) ||
          ("cyberwareType" in sys) ||
          ("CyberBodyType" in sys) ||
          ("Module" in sys) ||
          (sys.CyberWorkType && ("OptionsAvailable" in sys.CyberWorkType));

        if (!touched) return;

        const isThisModule = !!this.item.system?.Module?.IsModule;
        const isThisImplant = cwHasType(this.item, "Implant");

        // Module sheet: re-render when any cyberware on this actor changes in a way that affects the parent list/slots
        if (isThisModule) {
          this.render(false);
          return;
        }

        // Implant sheet: re-render only if a module touching this implant changed
        if (isThisImplant) {
          const mod = item.system?.Module;
          if (mod?.IsModule && mod?.ParentId === this.item.id) {
            this.render(false);
          }
        }
      };

      Hooks.on("updateItem", this._cp_boundOnItemUpdate);

      const closeHook = `close${this.constructor.name}`;
      this._cp_unbindOnClose = (app) => {
        if (app !== this) return;
        Hooks.off("updateItem", this._cp_boundOnItemUpdate);
        Hooks.off(closeHook, this._cp_unbindOnClose);
      };
      Hooks.on(closeHook, this._cp_unbindOnClose);
    }

    // MODULE: toggling equipped should refresh parent implant sheet (slots left)
    html.on("change", "input[name='system.equipped']", async ev => {
      const checked = !!ev.currentTarget.checked;
      await this.item.update({ "system.equipped": checked }, { render: false });

      const parentId = this.item.system?.Module?.ParentId || "";
      const parent = parentId ? this.actor?.items?.get(parentId) : null;
      if (parent?.sheet?.rendered) parent.sheet.render(true);

      this.render(false);
    });
  }

  /** @override */
  async _updateObject(event, formData) {
    const data = foundry.utils.expandObject(formData);

    if (this.item.type === "cyberware") {
      const pickLastString = (v) => Array.isArray(v) ? String(v[v.length - 1] ?? "") : String(v ?? "");

      const t = foundry.utils.getProperty(data, "system.cyberwareType");
      if (t !== undefined) foundry.utils.setProperty(data, "system.cyberwareType", pickLastString(t));

      const ap = foundry.utils.getProperty(data, "system.Module.AllowedParentCyberwareType");
      if (ap !== undefined) foundry.utils.setProperty(data, "system.Module.AllowedParentCyberwareType", pickLastString(ap));

      const slots = Number(foundry.utils.getProperty(data, "system.Module.SlotsTaken"));
      if (!Number.isFinite(slots)) foundry.utils.setProperty(data, "system.Module.SlotsTaken", 0);
    }
    if (this.item.type === "cyberware") {
      const pickLastString = (v) => {
        if (Array.isArray(v)) return v.length ? String(v[v.length - 1] ?? "") : "";
        return v == null ? "" : String(v);
      };
      const t = foundry.utils.getProperty(data, "system.cyberwareType");
      if (t !== undefined) {
        foundry.utils.setProperty(data, "system.cyberwareType", pickLastString(t));
      }

      const ap = foundry.utils.getProperty(data, "system.Module.AllowedParentCyberwareType");
      if (ap !== undefined) {
        foundry.utils.setProperty(data, "system.Module.AllowedParentCyberwareType", pickLastString(ap));
      }

      const slots = foundry.utils.getProperty(data, "system.Module.SlotsTaken");
      if (slots !== undefined) {
        const n = Number(slots);
        foundry.utils.setProperty(data, "system.Module.SlotsTaken", Number.isFinite(n) ? n : 0);
      }
    }

    if (this.item.type === "skill") {
      const fixNum = v => {
        const n = parseInt(v ?? 0, 10);
        return isNaN(n) ? 0 : n;
      };
      foundry.utils.setProperty(data, "system.level", fixNum(foundry.utils.getProperty(data,"system.level")));
      foundry.utils.setProperty(data, "system.chipLevel", fixNum(foundry.utils.getProperty(data,"system.chipLevel")));
    }

    const legacy = foundry.utils.getProperty(data, "system.chipped");
    if (legacy !== undefined) {
      foundry.utils.setProperty(data, "system.isChipped", !!legacy);
      if (data.system && "chipped" in data.system) delete data.system.chipped;
    }

    if (this.item.type === "cyberware") {
    const equip = foundry.utils.getProperty(data, "system.equipped");
    if (equip === true) {
      const zone = String(
        foundry.utils.getProperty(data, "system.MountZone") ||
        foundry.utils.getProperty(data, "system.CyberBodyType.Type") ||
        this.item.system?.MountZone ||
        this.item.system?.CyberBodyType?.Type ||
        ""
      );
      const loc = String(
        foundry.utils.getProperty(data, "system.CyberBodyType.Location") ||
        this.item.system?.CyberBodyType?.Location ||
        ""
      );
      if ((zone === "Arm" || zone === "Leg") && !loc) {
        foundry.utils.setProperty(data, "system.CyberBodyType.Location", "Left");
      }
    }
  }

    await this.item.update(data);
  }

  /**
   * Collect the chip level aggregate for all of the actor's chip implants
   * Take the maximum, key = skill name (as on the sheet)
  */
  async _cp_syncChipLevelsToSkills() {
    const actor = this.item.actor;
    if (!actor) return;

    const chipItems = actor.items.filter(i =>
      i.type === "cyberware" &&
      cwHasType(i, "Chip")
    );

    const agg = {};
    for (const cw of chipItems) {
      const map = cw.system?.CyberWorkType?.ChipSkills || {};
      for (const [name, lvl] of Object.entries(map)) {
        const n = Number(lvl) || 0;
        if (n < 0) continue;
        agg[name] = Math.max(agg[name] ?? 0, n);
      }
    }

    const skillItems = actor.items.filter(i => i.type === "skill");
    const updates = [];
    for (const s of skillItems) {
      if (!(s.name in agg)) continue;
      const want = Number(agg[s.name] || 0);
      const cur = Number(s.system?.chipLevel || 0);
      if (want !== cur) {
        updates.push({ _id: s.id, "system.chipLevel": want });
      }
    }
    if (updates.length) await actor.updateEmbeddedDocuments("Item", updates);
  }
  /**
   * Set system.isChipped for skills based on all active chips of the actor
   * true — if there is at least one active chip for the skill that grants this skill
   * false — if there are no active chips for the skill
  */
  async _cp_syncActiveFlagsToSkills() {
    const actor = this.item.actor;
    if (!actor) return;

    const activeChips = actor.items.filter(i =>
      i.type === "cyberware" &&
      cwHasType(i, "Chip") &&
      !!i.system?.CyberWorkType?.ChipActive
    );

    const activeMap = {};
    for (const ch of activeChips) {
      const skills = ch.system?.CyberWorkType?.ChipSkills || {};
      for (const name of Object.keys(skills)) activeMap[name] = true;
    }

    const skills = actor.items.filter(i => i.type === "skill");
    const updates = [];
    for (const s of skills) {
      const want = !!activeMap[s.name];
      const cur = !!(s.system?.isChipped);
      if (want !== cur) updates.push({ _id: s.id, "system.isChipped": want });
    }
    if (updates.length) await actor.updateEmbeddedDocuments("Item", updates, { render: false });
  }
}
